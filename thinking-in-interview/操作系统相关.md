### Linux IO

#### 1. sync、fsync与fdatasync

传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式被称为延迟写`（delayed write）`。

**延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度**，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，**UNIX系统提供了sync、fsync和fdatasync三个函数。**

- sync：是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。通常称为`update的系统守护进程`会周期性地`（一般每隔30秒）`调用sync函数。这就保证了定期冲洗内核的块缓冲区。
- fsync：只对由文件描述符`filedes`指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。**fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上**。而除数据外，fsync还会同步更新文件的属性。
- fdatasync：函数类似于fsync，**但它只影响文件的数据部分。仅在需要的时候同步更新文件的属性**。

#### 2.fsync的性能问题，以及与fdatasync区别

除了同步文件的修改内容（脏页），`fsync`还会**同步文件的描述信息（metadata，包括size、访问时间st_atime & st_mtime等等）**，因为**文件的数据和metadata通常存在硬盘的不同地方，因此fsync至少需要两次IO写操作**。

多余的一次IO操作，有多么昂贵呢？当前硬盘驱动的平均寻道时间`（Average seek time）`大约是`3~15ms`，7200转硬盘的平均旋转延迟`（Average rotational latency）`大约为`4ms`，因此**一次IO操作的耗时大约为10ms左右**。

`fdatasync`的功能与`fsync`类似，但是**仅仅在必要的情况下才会同步metadata，因此可以减少一次IO写操作**。

什么是“必要的情况”呢？比如文件的尺寸（`st_size`）如果变化，是需要立即同步的，否则OS一旦崩溃，即使文件的数据部分已同步，由于metadata没有同步，依然读不到修改的内容。而最后访问时间(atime)/修改时间(mtime)是不需要每次都同步的，只要应用程序对这两个时间戳没有苛刻的要求，基本无伤大雅。

