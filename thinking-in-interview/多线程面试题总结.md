#### 1、知识点网址记录

>- wait-notify应用demo https://blog.csdn.net/jiangzhexi/article/details/81152617
>- Java并发编程之LockSupport、Unsafe详解 https://blog.csdn.net/qq_38293564/article/details/80512758
>- LockSupport解析与使用 https://blog.csdn.net/SecSF/article/details/78560013?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1
>- 线程池源码分析 https://www.cnblogs.com/huangjuncong/p/10031525.html
                https://blog.csdn.net/programmer_at/article/details/79799267

#### 2.线程的状态又那些，状态是如何转换的？
>- 首先Thread类中的内部枚举类public enum State定义了六个状态。
    
>- NEW(新创建)：new Thread()还没有运行start()方法

>- RUNNABLE(可运行)：1、线程执行start方法后NEW进入RUNNABLE状态，
                    2、BLOCKED状态的线程获得monitor锁，BLOCKED进入到RUNNABLE状态
                    3、Object.notify()获得monitor锁、Object.notifyAll()方法获得monitor锁、join方法执行完毕、LockSupport.unpark()方法都会由WAITING/TIMEDWAITING进入RUNNABLE状态
               

>- BLOCKED(被阻塞)：1、线程进入synchronized保护的代码(代码块或者方法),没有抢到monitor锁，RUNNABLE进入到BLOCKED状态
                   2、Object.notify()未获得monitor锁、Object.notifyAll()方法未获得monitor锁、join方法执行完毕、LockSupport.unpark()方法都会由WAITING/TIMEDWAITING进入BLOCKED状态

>- WAITING(等待)：在调用Object.wait()方法、Thread.join()和LockSupport.park()方法,会使用线程由RUNNABLE进入WAITING状态

>- TIMED WAITING(等待)：在调用Object.wait(long timeout)方法、Thread.sleep(long millis)、Thread.join(long millis)、LockSupport.parkUntil(long deadline)和LockSupport.parkNanos(long nanos)方法,会使用线程由RUNNABLE进入TIMED WAITING状态

>- TERMINATED(终止)：RUNNABLE进入TERMINATED状态 1、run()方法执行完毕,线程正常退出 2、出现异常，终止run()方法

### 线程池面试题

#### 1、为什么使用线程池,优势是什么?

线程池的工作主要是控制运行线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。

特点：线程复用；控制最大并发数；管理线程。

优势：

> 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
>
> 第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
>
> 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
>

#### 2、线程池的几个重要参数介绍?

***corePoolSize：*** 核心池的大小。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；

***maximumPoolSize：*** 线程池最大线程数。这个参数也是一个非常重要的参数，它表示在线程池中最大能维持的线程数；

***keepAliveTime：*** 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；

***unit：*** 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性；

***workQueue：*** 一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue;　LinkedBlockingQueue;　SynchronousQueue;　PriorityBlockingQueue ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和SynchronousQueue。线程池的排队策略与BlockingQueue有关；

***threadFactory：*** 线程工厂，主要用来创建线程；

***handler：*** 表示当拒绝处理任务时的策略。

#### 3、线程池默认有几种拒绝策略？

默认有四种：

| 名称 | 作用 |
| --- | --- |
| AbortPolicy | 丢弃任务并抛出RejectedExecutionException异常，默认策略 |
| DiscardPolicy | 也是丢弃任务，但是不抛出异常 |
| DiscardOldestPolicy | 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） |
| CallerRunsPolicy | 由调用线程处理该任务 |

#### 4、JDK中默认线程池的创建有几种？

***newSingleThreadExecutor***

创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。使用LinkedBlockingQueue阻塞队列。

***newFixedThreadPool***

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。使用LinkedBlockQueue队列。

***newCachedThreadPool***

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程默认存活1分钟，使用SynchronousQueue阻塞队列。

与其他Java线程池比较，当新任务到来时，线程池会创建一个线程。如果此任务没有执行完，又往线程池添加任务，线程池又会创建新的线程处理新加任务。如果有任务执行完毕，并且没超过1分钟，这时又有新任务进来，此时不会创建新线程，而是使用执行完测任务的线程进行对新任务进行处理。但是假如线程池中任务都没处理完，又有大批量的任务进来，系统会由于大量线程创建执行而瘫痪。

这种类型的线程池特点是：

- 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
- 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
- 在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

***newScheduledThreadPool***

创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。使用DelayedWorkQueue队列。

***newSingleThreadScheduledExecutor***

创建只有一条线程的线程池，他可以在指定延迟后执行线程任务。

***newWorkStealingPool***

创建一个拥有多个任务队列（以便减少连接数）的工作窃取算法线程池。

#### 5、线程池的执行流程是什么？

- 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
- 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
- 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
- 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
- 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

### ThreadLocal解析

>- 1、应用实例:
     https://blog.csdn.net/qq_27127145/article/details/83894400

### 同步阻塞相关

#### 1.阻塞队列和非阻塞队列的区别?

阻塞队列与普通队列的区别在于，**当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列。**
 
#### 2.JDK提供了哪些阻塞对了？

- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
- PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
- DelayQueue：一个使用优先级队列实现的无界阻塞队列。
- SynchronousQueue：一个不存储元素的阻塞队列。
- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

#### 3.synchronized底层原理，wait和notify底层原理？

比较麻烦。。后面整理吧。



