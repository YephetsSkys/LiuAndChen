#### 1、知识点网址记录

>- wait-notify应用demo https://blog.csdn.net/jiangzhexi/article/details/81152617
>- Java并发编程之LockSupport、Unsafe详解 https://blog.csdn.net/qq_38293564/article/details/80512758
>- LockSupport解析与使用 https://blog.csdn.net/SecSF/article/details/78560013?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1
>- 线程池源码分析 https://www.cnblogs.com/huangjuncong/p/10031525.html
                https://blog.csdn.net/programmer_at/article/details/79799267

#### 2.线程的状态又那些，状态是如何转换的？
>- 首先Thread类中的内部枚举类public enum State定义了六个状态。
    
>- NEW(新创建)：new Thread()还没有运行start()方法

>- RUNNABLE(可运行)：1、线程执行start方法后NEW进入RUNNABLE状态，
                    2、BLOCKED状态的线程获得monitor锁，BLOCKED进入到RUNNABLE状态
                    3、Object.notify()获得monitor锁、Object.notifyAll()方法获得monitor锁、join方法执行完毕、LockSupport.unpark()方法都会由WAITING/TIMEDWAITING进入RUNNABLE状态
               

>- BLOCKED(被阻塞)：1、线程进入synchronized保护的代码(代码块或者方法),没有抢到monitor锁，RUNNABLE进入到BLOCKED状态
                   2、Object.notify()未获得monitor锁、Object.notifyAll()方法未获得monitor锁、join方法执行完毕、LockSupport.unpark()方法都会由WAITING/TIMEDWAITING进入BLOCKED状态

>- WAITING(等待)：在调用Object.wait()方法、Thread.join()和LockSupport.park()方法,会使用线程由RUNNABLE进入WAITING状态

>- TIMED WAITING(等待)：在调用Object.wait(long timeout)方法、Thread.sleep(long millis)、Thread.join(long millis)、LockSupport.parkUntil(long deadline)和LockSupport.parkNanos(long nanos)方法,会使用线程由RUNNABLE进入TIMED WAITING状态

>- TERMINATED(终止)：RUNNABLE进入TERMINATED状态 1、run()方法执行完毕,线程正常退出 2、出现异常，终止run()方法

### 线程池面试题

#### 1、为什么使用线程池,优势是什么?

线程池的工作主要是控制运行线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。

特点：线程复用；控制最大并发数；管理线程。

优势：

> 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
>
> 第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
>
> 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
>

#### 2、线程池的几个重要参数介绍?

***corePoolSize：*** 核心池的大小。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；

***maximumPoolSize：*** 线程池最大线程数。这个参数也是一个非常重要的参数，它表示在线程池中最大能维持的线程数；

***keepAliveTime：*** 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；

***unit：*** 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性；

***workQueue：*** 一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue;　LinkedBlockingQueue;　SynchronousQueue;　PriorityBlockingQueue ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和SynchronousQueue。线程池的排队策略与BlockingQueue有关；

***threadFactory：*** 线程工厂，主要用来创建线程；

***handler：*** 表示当拒绝处理任务时的策略。

#### 3、线程池默认有几种拒绝策略？

默认有四种：

| 名称 | 作用 |
| --- | --- |
| AbortPolicy | 丢弃任务并抛出RejectedExecutionException异常，默认策略 |
| DiscardPolicy | 也是丢弃任务，但是不抛出异常 |
| DiscardOldestPolicy | 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） |
| CallerRunsPolicy | 由调用线程处理该任务 |

#### 4、JDK中默认线程池的创建有几种？

***newSingleThreadExecutor***

创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。使用LinkedBlockingQueue阻塞队列。

***newFixedThreadPool***

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。使用LinkedBlockQueue队列。

***newCachedThreadPool***

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程默认存活1分钟，使用SynchronousQueue阻塞队列。

与其他Java线程池比较，当新任务到来时，线程池会创建一个线程。如果此任务没有执行完，又往线程池添加任务，线程池又会创建新的线程处理新加任务。如果有任务执行完毕，并且没超过1分钟，这时又有新任务进来，此时不会创建新线程，而是使用执行完测任务的线程进行对新任务进行处理。但是假如线程池中任务都没处理完，又有大批量的任务进来，系统会由于大量线程创建执行而瘫痪。

这种类型的线程池特点是：

- 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
- 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
- 在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

***newScheduledThreadPool***

创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。使用DelayedWorkQueue队列。

***newSingleThreadScheduledExecutor***

创建只有一条线程的线程池，他可以在指定延迟后执行线程任务。

***newWorkStealingPool***

创建一个拥有多个任务队列（以便减少连接数）的工作窃取算法线程池。

#### 5、线程池的执行流程是什么？

- 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
- 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。
- 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
- 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
- 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

### ThreadLocal解析

>- 1、应用实例:
     https://blog.csdn.net/qq_27127145/article/details/83894400

### 同步阻塞相关

#### 1.阻塞队列和非阻塞队列的区别?

阻塞队列与普通队列的区别在于，**当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列。**
 
#### 2.JDK提供了哪些阻塞对了？

- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
- PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
- DelayQueue：一个使用优先级队列实现的无界阻塞队列。
- SynchronousQueue：一个不存储元素的阻塞队列。
- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

#### 3.synchronized底层原理，wait和notify底层原理？

`synchronized`修饰的方法会给方法标做标记（修饰实例方法则锁是this，修饰静态方法则锁是当前的类对象），如果修饰的代码块则会插入字节码指令`monitorenter`和`monitorexit`，一般会生成两个`monitorenter`指令，因为有异常的情况也需要解锁，不然就死锁了。从生成的字节码我们也可以得知，为什么 synchronized 不需要手动解锁？是有人在替我们负重前行啊！编译器生成的字节码都帮咱们做好了，异常的情况也考虑到了。

`synchronized`深入到JVM层的话，与对象的对象头息息相关，这里将对象头再次展示一下。

<table>
	<tr>
		<td rowspan="2">锁状态</td>
		<td colspan="2">25bit</td>
		<td rowspan="2">4bit</td>
		<td>1bit</td>
		<td>2bit</td>
	</tr>
	<tr>
		<td>23bit</td>
		<td>2bit</td>
		<td>是否偏向锁</td>
		<td>锁标志位</td>
	</tr>
	<tr>
		<td>无锁状态</td>
		<td colspan="2">对象的hashcode</td>
		<td>分代年龄</td>
		<td>0</td>
		<td>01</td>
	</tr>
	<tr>
		<td>偏向锁</td>
		<td>线程ID</td>
		<td>Epoch</td>
		<td>分代年龄</td>
		<td>1</td>
		<td>01</td>
	</tr>
	<tr>
		<td>轻量级锁</td>
		<td colspan="4">指向栈中锁记录的指针</td>
		<td>00</td>
	</tr>
	<tr>
		<td>重量级锁</td>
		<td colspan="4">指向互斥量(重量级锁)的指针</td>
		<td>10</td>
	</tr>
	<tr>
		<td>GC标记</td>
		<td colspan="4">空</td>
		<td>11</td>
	</tr>
</table>

每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。

```
ObjectMonitor() {
    _header       = NULL;
    _count        = 0;  // 锁计数器
    _waiters      = 0,
    _recursions   = 0; // 记录重入次数
    _object       = NULL; // 存储锁对象，如synchroinzed(object) 这个object对象
    _owner        = NULL; // 标识当前拥有该锁的线程
    _WaitSet      = NULL; // 处于wait方法的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ; // 多个线程争抢锁会先存在这个列表中
    FreeNext      = NULL ;
    _EntryList    = NULL ; // 处于等待锁block状态的线程，会被加入到该列表（它这里搞了_cxq和_EntryList两个队列）
    _SpinFreq     = 0 ;       // 注意：线程在任何时候只会出现在_cxq或者_EntryList一个队列中
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```

这里发一下锁的状态变更图
![avatar](img/java锁状态变化图.png)

***1) 偏向锁***

如果一开始一直只有一个线程持有这个锁，也不会有其他线程来竞争，此时频繁的 CAS 是没有必要的，CAS 也是有开销的。（这里说的CAS指的是轻量级锁使用CAS将`Mark Word`更新为指向锁记录的指针）

原理也不难，如果当前锁对象支持偏向锁，那么就会通过`CAS`操作：将当前线程的地址记录到`markword`中，并且将标记字段的最后三位设置为`101`。之后有线程请求这把锁，只需要判断`markword`最后三位是否为`101`，是否指向的是当前线程的地址。同时还需要判断`epoch`值是否和锁对象的类中的`epoch`值相同。如果都满足，那么说明当前线程持有该偏向锁，就可以直接返回。

> 一个对象被认为已经偏向了某个线程必须满足两个条件：
> - `MarkWord`中`Thread Id`是线程T的Id；
> - `Mark Word`中的`epoch`必须是和类的`epoch`相等。

如果下一个线程要获取锁的时候，会检测对象头的`Mark Word`，如果对象是可偏向的，但是偏向线程的ID和当前要获取到偏向锁的线程ID不同，则证明这个偏向锁对象目前偏向于其他线程，需要撤销偏向锁模式。（Revoke Rebias）（注意这里是撤销，而不是解锁，因为现在需要将偏向锁的模式进行膨胀）

偏向锁的撤销是一个很特殊的操作，为了执行撤销操作，需要等待全局安全点（Safe Point），此时间点所有的工作线程都停止了字节码的执行。在进入到膨胀流程的时候，会有一个判断，判断持有这个偏向锁的线程是否正在执行同步代码块，如果持有偏向锁的线程已经执行完了，就应该将偏向锁对象的`Mark Word`置为无锁状态。但是，如果持有偏向锁的线程还没有执行完同步代码块，应该直接将这个偏向锁的膨胀为轻量锁。

后面的就是走轻量锁的逻辑了。

> 这里补充一下，为什么需要等待全局安全点（Safe Point）的时候才能进行膨胀？
> 首先这个此时间点所有的工作线程都停止了字节码的执行。
> 其次就是线程A在占用偏向锁执行同步代码块的时候，线程B也要抢占偏向锁，证明出存在多线程竞争，线程B就需要将这个偏向锁进行膨胀，这也就意味这个线程B需要操作线程A的线程栈，所以需要等待一个时间点，让线程B来操作，这个时间点就是`stop the world`的时候，没有字节码执行的时候。

> 偏向锁膨胀具体流程：

当线程A在通过CAS方式获取偏向锁对象的时候，会在线程A的栈帧中建立一个锁记录（`Lock Record`）。

如果线程B在进行抢占，所以需要撤销偏向锁模式，在全局安全点的时候，如果发现线程A持有偏向锁，但是还没有执行完同步代码块，线程B会遍历线程A里面的栈帧，查找到所有与当前偏向锁对象相关联的锁记录（Lock Record），修改这些锁记录（Lock Record）里的内容为轻量级锁的内容，然后把`最老的`（oldest、栈帧）一个锁记录（`Lock Record`）的指针写到锁对象的`Mark Word`里，就好像是原来从没有使用过偏向锁，使用的一直是轻量级锁一样。

至于为什么是最老的，因为A有可能重入了很多次，则栈帧中记录的是个null，所以需要把“最老的”锁记录的指针写到对象的`Mark Word`里。从而B线程完成了锁膨胀的流程。

> 前面提的`epoch`干啥用的？

可以简单理解为是第几代偏向锁。偏向锁在有竞争的时候是要执行撤销操作的，其实就是要升级成轻量级锁。而当一类对象撤销的次数过多，次数到了一定阈值(`-XX:BiasedLockingBulkRebiasThreshold`，默认为`20`)就会把这一代的偏向锁废弃，把类的`epoch`加一。

所以当类对象和锁对象的`epoch`值不等的时候，当前线程可以将该锁重偏向至自己，因为前一代偏向锁已经废弃了。



