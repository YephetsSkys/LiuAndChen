> HTTP和HTTPS的请求流程也是面试的时候一大考点，如果不掌握的话，容易丢失印象分。这两种请求都是基于TCP/IP，不明白的请看上一篇文章。这里总结HTTP/HTTPS请求的整个过程，以备不时之需。

### 一、HTTP请求的过程

#### 1.浏览器根据域名解析IP地址

浏览器根据访问的域名找到其IP地址。DNS查找过程如下：
>- 浏览器缓存：首先搜索浏览器自身的DNS缓存（缓存的时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否是有域名对应的条目，而且没有过期，如果有且没有过期则解析到此结束。
>- 系统缓存：如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索解析到此结束。
>- 路由器缓存：如果系统缓存也没有找到，则会向路由器发送查询请求。
>- ISP（互联网服务提供商） DNS缓存：如果在路由缓存也没找到，最后要查的就是ISP缓存DNS的服务器。

#### 2.浏览器与WEB服务器建立一个TCP连接

TCP的3次握手过程。

#### 3.浏览器给WEB服务器发送一个HTTP请求

一个HTTP请求报文由`请求行`（request line）、`请求头部`（headers）、`空行`（blank line）和`请求数据`（request body）4个部分组成。

##### 请求行

请求行分为三个部分：***请求方法***、***URL***和***HTTP***协议版本，它们之间用空格分割。例如，GET /index.html HTTP/1.1；

***请求方法***

HTTP/1.1 定义的请求方法有8种：GET（完整请求一个资源）、POST（提交表单）、PUT（上传文件）、DELETE（删除）、PATCH、HEAD（仅请求响应首部）、OPTIONS（返回请求的资源所支持的方法）、TRACE（追求一个资源请求中间所经过的代理）。最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。

***URL***

统一资源定位符，是一种资源位置的抽象唯一识别方法。
组成：<协议>://<主机>:<端口>/<路径>

***协议版本***

协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1

##### 请求头部

请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据。下面列出小部分请求头内容：

| 请求头 | 说明 |
| ------ | ------ |
| Host | 接受请求的服务器地址，可以是IP:端口，也可以是域名 |
| User-Agent | 发送请求的应用程序信息 |
| Connection | 指定与连接相关的属性，如Connection:Keep-Alive |

##### 请求数据

请求数据一般用在POST、PUT等请求上，如：
```
username=aa&password=1234
//或
{"username":"aa","password":"1234"}
```

#### 4.服务器端响应HTTP请求，浏览器得到HTML代码

HTTP响应报文由`状态行`（status line）、`响应头部`（headers）、`空行`（blank line）和`响应数据`（response body）4个部分组成。

##### 状态行

状态行由3部分组成，分别为：`协议版本`、`状态码`、`状态码描述`。其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。如下：
```
Status Code: 200 OK
//或者
Status Code: 302 Found
```

##### 响应头部

下面列出部分响应头内容：
| 响应头 | 说明 |
| ----- | ----- |
| Server | 服务器应用程序软件的名称和版本 |
| Content-Type | 响应正文的类型 |
| Content-Length | 响应正文长度 |

##### 响应数据

用于存放需要返回给客户端的数据信息。如下：

```
<html>
<head><title>响应信息</title></head>
<body>我是正文</body>
</html>
```

#### 5.浏览器解析HTML代码，并请求HTML代码中的资源

浏览器拿到HTML文件后，开始解析HTML代码，遇到静态资源时，就向服务器端去请求下载。

#### 6.关闭TCP连接，浏览器对页面进行渲染呈现给用户

浏览器利用自己内部的工作机制，把请求到的静态资源和HTML代码进行渲染，呈现给用户。完成后根据Connection来决定是否关闭TCP连接。

### 二、HTTPS请求的过程

HTTP 协议由于其简单快速、占用资源少，一直被用于网站服务器和浏览器之间进行数据传输。但是在数据传输的过程中也存在很明显的问题，由于 HTTP 是明文协议，不会对数据进行任何方式的加密。当黑客攻击窃取了网站服务器和浏览器之间的传输报文的时，可以直接读取传输的信息，造成网站、用户资料的泄密。因此 HTTP 不适用于敏感信息的传播，这个时候需要引入 HTTPS（超文本传输安全协议）。

我们下面将具体过程整理如下：

>- 1.客户端向服务器发起HTTPS的请求，连接到服务器的443端口；
>- 2.服务器将非对称加密的公钥传递给客户端，以证书的形式回传到客户端；
>- 3.客户端接受到该公钥进行验证，如果有问题，则HTTPS请求无法继续；如果没有问题，客户端这个时候随机生成一个私钥，称为`client key`,用于对称加密数据的。使用前面的公钥对`client key`进行非对称加密；客户端发起二次HTTP请求，将加密之后的`client key`传递给服务器；
>- 4.服务器使用私钥进行解密，得到`client key`,使用`client key`对数据进行对称加密；
>- 5.将对称加密的数据传递给客户端，客户端使用对称解密，得到服务器发送的数据，完成第二次HTTP请求。

![avatar](img/20200416173531.png)

### 三、HTTPS和HTTP的区别

通过上面详细对HTTPS的分析，我们可得：
>- HTTPS是密文传输，HTTP是明文传输；
>- 默认连接的端口号是不同的，HTTPS是443端口，而HTTP是80端口；
>- HTTPS请求的过程需要CA证书要验证身份以保证客户端请求到服务器端之后，传回的响应是来自于服务器端，而HTTP则不需要CA证书；
>- HTTPS=HTTP+加密+认证+完整性保护。

![avatar](img/20200416193226.png)

### 四、HTTPS 加密算法

为了保护数据的安全，HTTPS 运用了诸多加密算法：

1. ***对称加密：***有流式、分组两种，加密和解密都是使用的同一个密钥。

 例如：DES、AES-GCM、ChaCha20-Poly1305 等。

2. ***非对称加密：***加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。

 例如：RSA、DSA、ECDSA、 DH、ECDHE 等。

3. ***哈希算法：***将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。

 例如：MD5、SHA-1、SHA-2、SHA-256 等。

4. ***数字签名：***签名就是在信息的后面再加上一段内容（信息经过 hash 后的值），可以证明信息没有被修改过。hash 值一般都会加密后（也就是签名）再和信息一起发送，以保证这个 hash 值不被修改。

### 五、Http属性相关问题

#### 1.请问TCP的Keepalive和HTTP的Keep-Alive是一个东西吗？

**这两个完全是两样不同的东西**，实现的层面也不同：
- Http的Keep-Alive，是由**应用层（用户态）**实现的，称为HTTP长连接；
- TCP的Keepalive，是由**TCP层（内核态）**实现的，称为TCP保活机制；

> HTTP的Keep-Alive

由于HTTP是基于TCP传输协议实现的，客户端与服务端要进行HTTP通信前，首先需要建立TCP连接，然后客户端发送HTTP请求，服务端收到后就返回响应，随后就会释放TCP连接。

如果每次请求都要经历**三次握手、四次挥手**这样的过程，那么次方式就是**HTTP短连接**，非常的耗损性能。

Keep-Alive就是可以实现TCP长连接的机制，在第一个HTTP请求完成后，暂时先不断开TCP连接，让后续的HTTP请求继续使用此连接。我们称这种方法为**HTTP长连接**。

在`HTTP1.0`中**默认是关闭状态**，如果浏览器要开启Keep-Alive，它必须在请求的头中添加：
```
Connection: Keep-Alive
```

然后服务器收到请求后，作出回应的时候，它也添加这个头信息在响应中，这样子，连接就不会被终端。直至其中一方主动或被动的断开连接。

从`HTTP1.1`开始，**默认是开启状态**，如果要关闭Keep-Alive，需要在请求的头信息中添加：
```
Connection: close
```

HTTP长连接不仅仅减少了TCP连接资源的开销，而且这给`HTTP流水线`技术提供了实现的基础。所谓`HTTP流水线`，是客户端可以先一次性发送多个请求，而在发送过程中不需要先等待服务器的回应，可以减少整体的响应时间。

同时为了减少不必要的TCP连接，一般会设置一个超时时间，如果在指定的时间内客户端没有发起新的请求，会将TCP连接关闭，减少资源的开销。

> TCP的Keepalive

TCP的Keepalive其实是TCP的保活机制。定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用。每隔一个时间间隔，发送一个探测报文，如果连续N个探测报文都没有响应，则认为当前的TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。

在Linux内核有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下为默认值：
```
net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75 
net.ipv4.tcp_keepalive_probes=9
```
- tcp_keepalive_time=7200：表示保活时间是 7200 秒（2⼩时），也就 2 ⼩时内如果没有任何连接相关的活动，则会启动保活机制；
- tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；
- tcp_keepalive_probes=9：表示检测 9 次⽆响应，认为对⽅是不可达的，从⽽中断本次的连接。

也就是说在**Linux 系统中，最少需要经过 2 ⼩时 11 分 15 秒才可以发现⼀个「死亡」连接。**
```
//公式
tcp_keepalive_time + (tcp_keepalive_intvl * tcp_keepalive_probes)
```

这个时间是有点⻓的，我们也可以根据实际的需求，对以上的保活相关的参数进⾏设置。如果开启了 TCP 保活，需要考虑以下几种情况：

- **第⼀种，对端程序是正常⼯作的**。当`TCP`保活的探测报⽂发送给对端, 对端会正常响应，**这样`TCP`保活时间会被重置，等待下⼀个`TCP`保活时间的到来**。
- **第⼆种，对端程序崩溃并重启**。当`TCP`保活的探测报⽂发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产⽣⼀个`RST`报⽂，这样很快就会**发现`TCP`连接已经被重置**。
- **第三种，是对端程序崩溃，或对端由于其他原因导致报⽂不可达**。当`TCP`保活的探测报⽂发送给对端后，⽯沉⼤海，没有响应，连续几次，达到保活探测次数后，**`TCP`会报告该连接已经死亡**。

应用程序若想使用TCP保活机制，需要通过`socket`接口设置`SO_KEEPALIVE`选项才能够生效，如果没有设置，那么就无法使用TCP保活机制。
