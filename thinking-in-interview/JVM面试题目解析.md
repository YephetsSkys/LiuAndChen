### 一、JVM基础知识

#### 1.详解JVM内存结构

>- 程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有；
>- Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有；
>- 本地方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有；
>- Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享；
>- 方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享；
>- 直接内存：这部分内存不是Java虚拟机规范中定义的内存区域。不受Java堆大小的限制，但是也可能导致OOM的产生；（可以不用说）

#### 2.谈一谈Java的内存模型（JMM）

Java的内存模型就是一种符合内存模型规范的，屏蔽各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

Java内存模型规定了所有的变量都存储在主内存中，每条线程拥有自己独立的工作内存，线程的工作内存中保存了该线程中使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步。

关于主内存与工作内存之间具体的交互协议，即一个变量如果从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可在分的。（double和long在32位机器上是例外）

>- lock(锁定):作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量；
>- unlock(解锁):作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定；
>- read(读取):作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用；
>- load(载入):作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)；
>- use(使用):作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作；
>- assign(赋值):作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作；
>- store(存储):作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用；
>- write(写入):作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中；

作用于主内存的操作有：lock、unlock、read、write。

作用于工作内存的操作有：load、user、assign、store。

对于这8中操作，虚拟机也规定了一系列规则，在执行这8中操作的时候必须遵循如下的规则：
>- ***不允许read和load、store和write操作之一单独出现***，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况；
>- ***不允许一个线程丢弃最近的assign操作***，也就是不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存；
>- ***不允许一个线程回写没有修改的变量到主内存***，也就是如果线程工作内存中变量没有发生过任何assign操作，是不允许将该变量的值回写到主内存；
>- ***变量只能在主内存中产生***，不允许在工作内存中直接使用一个未被初始化的变量，也就是没有执行load或者assign操作。也就是说在执行use、store之前必须对相同的变量执行了load、assign操作；
>- ***一个变量在同一时刻只能被一个线程对其进行lock操作***，也就是说一个线程一旦对一个变量加锁后，在该线程没有释放掉锁之前，其他线程是不能对其加锁的，但是同一个线程对一个变量加锁后，可以继续加锁，同时在释放锁的时候释放锁次数必须和加锁次数相同；
>- ***对变量执行lock操作，就会清空工作空间该变量的值***，执行引擎使用这个变量之前，需要重新load或者assign操作初始化变量的值；
>- ***不允许对没有lock的变量执行unlock操作***，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作；
>- ***对一个变量执行unlock之前，必须先把变量同步回主内存中***，也就是执行store和write操作；

对volatile修饰的变量的特殊规则：

>- 线程使用use动作必须跟read、load动作相关联，用于保证线程能看得见其他线程对变量的最新修改后的值；
>- 线程使用assign动作必须跟store、write动作相关联，用于保证线程对变量的修改能立刻被其他线程看到；
>- 线程A对变量X实施use动作，线程B对变量Y实施use动作，如果线程A动作先于B，那么线程A的read动作肯定也先于线程B的read动作。同一个线程内部，被volatile修饰的变量不会被指令重排序，保证代码的执行顺序和程序的顺序相同；

#### 3.Java内存堆和栈区别

>- 栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；
>- 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问；
>- 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError；
>- 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小；

#### 4.强引用、软引用、弱引用、虚引用的区别？

>- 强引用（StrongReference）强引用是使用最普遍的引用（默认Java的赋值变量基本都是强引用了）。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题；
>- 软引用（SoftReference）如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中；
>- 弱引用（WeakReference）在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中；
>- 虚引用（PhantomReference）虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

#### 5.请说一说运行时栈帧的结构？

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。

栈帧存储了方法的局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

#### 6.说说GC ROOT的对象有哪几种？

>- 虚拟机栈（栈帧中的本地变量表）中的引用的对象；
>- 方法区中的类静态属性引用的对象；
>- 方法区中的常量引用的对象；
>- 本地方法栈中JNI(即一般说的Native方法)的引用的对象；

#### 7.类的生命周期

类的生命周期包括这几部分，加载、连接（验证、准备、解析）、初始化、使用和卸载。

加载阶段主要完成以下3件事情：通过一个类的全限定名来获取定义此类的二进制字节流；将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；加载阶段和连接阶段可能会交替进行。

验证是连接阶段的第一步，这一阶段主要是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求并且不会危害虚拟机自身的安全。验证阶段大致完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这边变量的所使用的内存都将在方法区中进行分配。这个阶段的内存分配仅仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化的时随着对象一起分配在Java堆中。其次，这里所说的初始化“通常情况”下是数据类型的零值，除非变量是final类型修饰的基本变量。

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其他动作完全由虚拟机主导和控制。到了初始化，才真正开始执行类中定义的Java程序代码。初始化阶段是执行类构造器<clinit>方法执行过程。

使用阶段就是在咱们实例化对象、工具方法调用等等，不介绍了。

卸载阶段中对无用的类回收，以释放一部分方法区的空间。但是要满足“无用的类”条件比较苛刻：该类所有的实例都已经被回收；加载该类的ClassLoader也被回收；该类的Class对象也没有任何地方被引用，并且无法在任何地方可以通过反射来访问该类的方法；满足上面的3个条件，就有可能会回收。

#### 8.<clinit>方法介绍

当类中包含静态块和静态变量（不包含static final的基本类型），java编译器会自动生成<clinit>方法，主要是用于在初始化阶段来初始化静态成员变量和静态逻辑。

<clinit>方法与类的构造方法冉，它不需要显示的调用父类构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>方法的类肯定是Object类了。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>方法。但接口与类不同的是，执行接口的<clinit>方法不需要先执行父接口的<clinit>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>方法。

虚拟机会保证一个类<clinit>方法在多线程环境中被正确加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>方法。

#### 9.类加载器双亲委派模型

检查类是否被加载：
自定义类加载器（User ClassLoader） -> 启动程序类加载器（Application ClassLoader） -> 扩展类加载器（Extension ClassLoader） -> 启动类加载器（Bootstrap ClassLoader） 

尝试加载类：
启动类加载器（Bootstrap ClassLoader） -> 扩展类加载器（Extension ClassLoader） -> 启动程序类加载器（Application ClassLoader） -> 自定义类加载器（User ClassLoader）

#### 10.双亲委派模式的弊端？

上层的ClassLoader无法访问底层的ClassLoader锁加载的类。JDK提供了一个方法： Thread.setContextClassLoader()可以解决这个问题。

#### 11.ClassLoader类加载器重要的4个方法介绍一下。

1.public Class<?> loadClass(String name) throws ClassNotFoundException

给定一个类名，加载一个类，返回代表这个类的Class实例，如果找不到类，则返回ClassNotFoundException。

2.protected final Class<?> defineClass(byte[] b, int off, int len)

根据给定的字节码流定义一个类，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组是ClassLoader从外部获取的。这是个受保护的方法，只有在自定义ClassLoader子类中可以使用。

3.protected final Class<?> findLoadedClass(String name)

这也是一个受保护的方法，它会去寻找已经加载的类。这个方法是final方法，无法被修改。

4.protected Class<?> findClass(String name) throws ClassNotFoundException

查找一个类，这是一个受保护的方法，也是重载ClassLoader时，重要的系统扩展点。这个方法会在loadClass()时被调用，用于自定义查找类的逻辑。如果不需要修改类加载默认机制，只是想改变类加载的形式，就可以重载该方法。

#### 12.

### 二、垃圾回收

#### 1.垃圾收集算法有哪些？

垃圾收集算法有复制算法、分代收集算法、标记-整理算法、标记-清除算法。

#### 2.请问吞吐量的优化和响应优先的垃圾收集器是如何选择的呢？

吞吐量优先首先看你使用新生代还是老年代，新生代采用的是Parallel Scavenge，然后老年代采用的是parallel Old的，最后配置多个线程进行回收的。还有就是我们可以设置参数进行调整最大垃圾收集停顿时间以及吞吐量的大小。

响应时间优先的话，我们可以这样这是老年代的收集器是一个CMS，新生代用parNew。如果堆非常大的话，建议使用G1垃圾收集器。

#### 3.请介绍一下MinorGC和FullGC。

>- Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制-回收算法；
>- Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除/整理算法；

### 三、JVM故障诊断与性能优化


### 四、JVM相关连环炮面试解析
